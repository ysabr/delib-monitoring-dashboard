import os
from datetime import datetime, timedelta, timezone

import requests
import pandas as pd
import streamlit as st
from dotenv import load_dotenv

load_dotenv()

OPS_MONITOR_BASE_URL = os.getenv("OPS_MONITOR_BASE_URL", "http://127.0.0.1:4000").strip()
OPS_MONITOR_TOKEN = os.getenv("OPS_MONITOR_TOKEN", "").strip()

DO_TOKEN = os.getenv("DO_TOKEN", "").strip()
DO_DROPLET_ID = os.getenv("DO_DROPLET_ID", "").strip()
RANGE_HOURS = int(os.getenv("RANGE_HOURS", "6"))

DO_API = "https://api.digitalocean.com/v2"

st.set_page_config(page_title="Delib Monitoring Dashboard", layout="wide")

def ops_get(path: str, params=None):
    headers = {}
    if OPS_MONITOR_TOKEN:
        headers["x-dashboard-token"] = OPS_MONITOR_TOKEN
    url = f"{OPS_MONITOR_BASE_URL}{path}"
    return requests.get(url, headers=headers, params=params, timeout=8)

def to_epoch(dt: datetime) -> int:
    return int(dt.timestamp())

def do_get_metric(metric_path: str, host_id: str, start: int, end: int) -> dict:
    if not DO_TOKEN:
        raise RuntimeError("DO_TOKEN is empty")
    if not host_id:
        raise RuntimeError("DO_DROPLET_ID is empty")

    url = f"{DO_API}/{metric_path.lstrip('/')}"
    headers = {"Authorization": f"Bearer {DO_TOKEN}"}
    params = {"host_id": host_id, "start": str(start), "end": str(end)}

    r = requests.get(url, headers=headers, params=params, timeout=15)
    ct = r.headers.get("content-type", "")

    if not r.ok:
        raise RuntimeError(f"DO {r.status_code} {r.reason} (content-type={ct}) body={r.text[:250]}")

    return r.json()

def series_to_df(resp: dict) -> pd.DataFrame:
    data = (resp or {}).get("data", {})
    result = data.get("result", []) or []
    rows = []
    for s in result:
        metric = s.get("metric", {})
        values = s.get("values", []) or []
        for ts, val in values:
            rows.append({
                "time": datetime.fromtimestamp(float(ts), tz=timezone.utc),
                "value": float(val),
                "metric": str(metric),
            })
    if not rows:
        return pd.DataFrame(columns=["time", "value", "metric"])
    return pd.DataFrame(rows).sort_values("time")

st.title("Deliberatorium â€” Monitoring & Notifications")
st.caption("Status + recent logs from delib-ops-monitor, and infra metrics from DigitalOcean Monitoring API.")

colA, colB = st.columns([1, 1])

with colA:
    st.subheader("Component status (from delib-ops-monitor)")
    try:
        summary = ops_get("/dashboard/summary").json()
        comps = summary.get("components", {})
        st.json(comps)
    except Exception as e:
        st.error(f"Failed to fetch /dashboard/summary: {e}")

with colB:
    st.subheader("Recent logs (from delib-ops-monitor)")
    try:
        logs = ops_get("/dashboard/logs", params={"limit": 50}).json().get("logs", [])
        if logs:
            df_logs = pd.DataFrame(logs)
            st.dataframe(df_logs.sort_values("ts", ascending=False), use_container_width=True, height=320)
        else:
            st.info("No logs received yet.")
    except Exception as e:
        st.error(f"Failed to fetch /dashboard/logs: {e}")

st.divider()
st.subheader("DigitalOcean Droplet metrics")

if not DO_TOKEN or not DO_DROPLET_ID:
    st.warning("Set DO_TOKEN and DO_DROPLET_ID in .env to show charts.")
else:
    now = datetime.now(timezone.utc)
    start_dt = now - timedelta(hours=RANGE_HOURS)
    start = to_epoch(start_dt)
    end = to_epoch(now)

    mcol1, mcol2 = st.columns(2)

    with mcol1:
        st.markdown("### Load average (1m)")
        try:
            resp = do_get_metric("monitoring/metrics/droplet/load_1", DO_DROPLET_ID, start, end)
            df = series_to_df(resp)
            if df.empty:
                st.info("No load_1 data returned.")
            else:
                st.line_chart(df.set_index("time")[["value"]])
        except Exception as e:
            st.error(f"Load1 error: {e}")

    with mcol2:
        st.markdown("### Memory (available vs total)")
        try:
            resp_av = do_get_metric("monitoring/metrics/droplet/memory_available", DO_DROPLET_ID, start, end)
            resp_tot = do_get_metric("monitoring/metrics/droplet/memory_total", DO_DROPLET_ID, start, end)

            df_av = series_to_df(resp_av).rename(columns={"value": "available"})
            df_tot = series_to_df(resp_tot).rename(columns={"value": "total"})

            if df_av.empty or df_tot.empty:
                st.info("No memory data returned.")
            else:
                a = df_av.set_index("time")[["available"]]
                t = df_tot.set_index("time")[["total"]]
                merged = a.join(t, how="outer").sort_index()
                st.line_chart(merged)
        except Exception as e:
            st.error(f"Memory error: {e}")

st.caption("Tip: if charts are empty, check droplet monitoring agent + token permissions.")
